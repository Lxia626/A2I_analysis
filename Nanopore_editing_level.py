#! /usr/bin/env python3

## the script is used for analyzing A2I editing
import sys, os
from python_analysis import base_pair, custom_sort
from collections import OrderedDict
import re

def arg(argv):

    import argparse
    parser = argparse.ArgumentParser(description="Editing level analysis according to VCF file generated by Nanopore pipeline", formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('-i', '--input', help="mpileup results for level analysis", type=str, required=True)
    parser.add_argument('-o', '--out', help="Output of the analysis", type=argparse.FileType('w'), required=True)
    parser.add_argument('-R', help="Reference editing sites ['/public/home/Songlab/songyl/database/editing_sites/Merged/human/human_all_merged_editing-sites_add-strand']", type=argparse.FileType('r'), required=True)
   
    args = parser.parse_args() 
    sys.stderr.write('args: '+str(args)+'\n')
    edit_dict = {}
    for line in args.R:
        edit_dict.setdefault(line.split('\t')[0], []).append((line.strip().split('\t')[2], int(line.split('\t')[1])))
    main(args.input, args.out, edit_dict)

def main(inputFile, outFile, refSiteDict):

    outFile.write('#chrom\tposition\tstrand\tcoverage\teditedreads\teditlevel\n')
    for rec in inputFile:
        ref_for, ref_rev, alt_for, alt_rev = rec.info['DP4']
        if rec.chrom in refSiteDict:
            for x in refSiteDict[rec.chrom]: 
                if x[1] > rec.pos: break
                elif x[1] < rec.pos: continue
                else:
                    strand = x[0]
                    if strand == '+':
                        if alt_for+ref_for == 0: continue
                        outFile.write('\t'.join([rec.chrom, str(rec.pos), strand, str(alt_for+ref_for), str(alt_for), str(round(alt_for/(alt_for+ref_for), 4))])+'\n')
                    else:
                        if alt_rev+ref_rev == 0: continue
                        outFile.write('\t'.join([rec.chrom, str(rec.pos), strand, str(alt_rev+ref_rev), str(alt_rev), str(round(alt_rev/(alt_rev+ref_rev), 4))])+'\n')

def match_info_parse(match_info, ref, depth, Pos, qual, qual_t=7):

    indel = re.findall(r'.[+-]\w+', match_info)
    head = re.findall(r'\^.[.,ATCGatcgNn]', match_info)
    end = re.findall(r'[.,ATCGatcgNn]\$', match_info)
    indel_length = list(map(lambda x:(int(re.findall(r'[0-9]+', x)[0]), re.findall(r'[a-zA-Z]+', x)[0]), indel)) # [(length, [string]), (length, [string]), ...]
    error_indel_idx = [x for x in range(len(indel_length)) if indel_length[x][0] != len(indel_length[x][1])] # to check whether all INDELs are distinguishable from SNV, e.g. '.-1CC'
    snv_m = list(re.sub(r'.[+-]\w+|\^.[.,ATCGatcgNn]|[.,ATCGatcgNn]\$', '', match_info))
    for _x in error_indel_idx:
        prefix_length = 2+len(str(indel_length[_x][0]))
        snv_m.extend(list(indel[_x][prefix_length+indel_length[_x][0]:]))
        indel[_x] = indel[_x][:prefix_length]+indel[_x][prefix_length:prefix_length+indel_length[_x][0]] # modify the INDEL information
    #sys.stderr.write('Pos: %s\nindel_length: %s\nindel: %s\nhead: %s\nend: %s\nsnv_m: %s\n' % (Pos, indel_length, indel, head, end, snv_m))
    confused_num = len(indel)
    indel.extend(head); confused_num += len(head)
    indel.extend(end); confused_num += len(end)
    indel.extend(snv_m)
    #sys.stderr.write('len(indel): %s; depth: %s\n' % (len(indel), depth))
    if len(indel) != depth: sys.stderr.write('Error at Pos %s\n' % (Pos)); sys.exit(); return([('.', 0)])
    snv_dict = Counter(snv_m)
    if set(snv_dict.keys()) & set(['A', 'C', 'G', 'T', 'a', 'c', 'g', 't']):
        mismatch_num = [(_k, snv_dict[_k]) for _k in snv_dict.keys() if _k in ['A', 'C', 'G', 'T', 'a', 'c', 'g', 't'] and _k.upper() != ref.upper()]
    else:
        mismatch_num = [('.', 0)]
    confused_num += snv_dict['*']# + snv_dict['>'] + snv_dict['<']

    return(snv_dict, confused_num, mismatch_num)

if __name__ == '__main__':
    arg(sys.argv)